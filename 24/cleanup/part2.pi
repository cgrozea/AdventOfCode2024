import util.
import sat.
p(A)=>println(A). %shorter alias
op("OR",X,Y,R)=>R#=(X#\/Y).  %add OR constraint
op("AND",X,Y,R)=>R#=(X#/\Y). %add AND constraint
op("XOR",X,Y,R)=>R#=(X#^Y).  %add XOR constraint
%evaluate X to a value R using potential swapps
e(Vx,Vy,M,Swappers,X,R)=> 
L=M.get(X,[notfound]),
if L=[R2] then
    if X[1]='x' then
        R=Vx[tail(X).to_int+1]
    else
            if X[1]='y' then
                R=Vy[tail(X).to_int+1]
            else
                R=R2,exit(0)
            end                
    end
else
   L=[_,Vafter|_],R=Vafter
end.

add_gate_constr(M,Swappers,Vx,Vy,L)=>
L=[V,Vafter,Vswap,Op,T1,T2,Name],
e(Vx,Vy,M,Swappers,T1,V1),
e(Vx,Vy,M,Swappers,T2,V2),
op(Op,V1,V2,V),
(sum(Vswap)#=0)#/\(Vafter#=V)
#\/ (sum(Vswap)#>0) #/\ 
(
Vswap[1] #/\ V#=Swappers[1]
#\/ Vswap[2] #/\ V#=Swappers[2]
#\/ Vswap[3] #/\ V#=Swappers[3]
#\/ Vswap[4] #/\ V#=Swappers[4]
#\/ Vswap[5] #/\ V#=Swappers[5]
#\/ Vswap[6] #/\ V#=Swappers[6]
#\/ Vswap[7] #/\ V#=Swappers[7]
#\/ Vswap[8] #/\ V#=Swappers[8]
)
#/\
(
Vswap[1]#/\ Vafter#=Swappers[2]
#\/ Vswap[2] #/\ Vafter#=Swappers[1]
#\/ Vswap[3] #/\ Vafter#=Swappers[4]
#\/ Vswap[4] #/\ Vafter#=Swappers[3]
#\/ Vswap[5] #/\ Vafter#=Swappers[6]
#\/ Vswap[6] #/\ Vafter#=Swappers[5]
#\/ Vswap[7] #/\ Vafter#=Swappers[8]
#\/ Vswap[8] #/\ Vafter#=Swappers[7]
)
.

madd(C,X,Y,Z)=>
foreach(I in 1..X.length)
    Z[I] #= (X[I] #^ Y[I] #^ C),
    D:=new_array(1),D::0..1,D:=D[1],
    D#=((X[I] + Y[I] + C) #>= 2),
    C:=D
end,
Z[Z.length]#=C.

v(X)=R=>R=[X[I]*2**(I-1):I in 1..X.length].sum.

check(X,Y,Z)=>v(X)+v(Y)=v(Z).

% main entry point
% command line parameters:
% - file name F
% - number of gates involved in swapps (8 in the AoC problem)
% - for how many random additions to constrain the circuit to function correctly: Steps
main([F,K0,Steps])=>
A=[X.split(": "): X in read_file_lines(F)] %parse the symbols definitions in the input file
,M=new_map() %stores the informations from the input file as a map with symbol names as keys
,W=new_set() %stores all symbol names
,foreach(L in A,L.length=2) %process the definitions of the constants (circuit inputs)
    M.put(L[1],[L[2].to_int]),
    W.put(L[1])
end
,VarSwaps=new_map(45) %stores the associated variable to a gate, the value after the potential swap
,foreach(L in A,L.length=5) %processes the definitions of the gates
    if M.has_key(L[5]) then %if already seen (shouldn't be the case)
        p("duplicate"),
        exit(0)
    end,
    V=new_array(1),V::0..1,V:=V[1], %gate output before swap
    Vafter=new_array(1),Vafter::0..1,Vafter:=Vafter[1], %gate output after swap
    Vswap=new_array(8),Vswap::0..1, %if this variable is swapped with any of the slots
    VarSwaps.put(L[5],Vswap), %associate these flags with the variable
    M.put(L[5],[V,Vafter,Vswap,L[2],L[1],L[3],L[5]]), %store the original gate info and the variables
    W.put(L[5]), %and make sure 
    W.put(L[1]), %the symbols involved 
    W.put(L[3])  %are collected
end
,K=K0.to_int
,SK=M.keys.sort
,SKN=SK.length
,Vars=[V:I in 1..SKN,M.get(SK[I])=[V,_|_]] %all vars
,Vaft=[V:I in 1..SKN,M.get(SK[I])=[_,V,_|_]] %all vars after swapps
,Vpos=[V:I in 1..SKN,M.get(SK[I])=[_,_,V|_]] %all swapp flags
,SG=[V:I in 1..SKN,M.get(SK[I])=[_,_,_,_,_,_,V]] %all symbols for gates
,SGN=SG.length
,foreach(X in Vpos)
    sum(X)#<=1 %every gate takes part in atmost one swap slot
end
,foreach(I in 1..K)
    sum([X[I]:X in Vpos])#=1 %every slot is used to swap the output of precisely one gate
end
,sum([sum(X):X in Vpos])#=K %there are exactly K swapped gate outputs
,Xs=[X:X in W.keys,X[1]='x'].sort % "X" symbols in order
,Ys=[X:X in W.keys,X[1]='y'].sort % "Y" symbols in order
,Zs=[X:X in W.keys,X[1]='z'].sort % "Z" symbols in order
,p(lengths=[Xs,Ys,Zs].map(length))
,Ax:=random(42) % geeky random seed
,foreach(Rep in 1..Steps.to_int) %generate Steps random additions
    p(Rep)    
    ,Swappers=new_array(8),Swappers::0..1 %the values swapped
    ,Vx:=[random(0,1):_ in Xs] %random X
    ,Vy:=[random(0,1):_ in Ys] %to add with random Y   
    ,p({Vx,Vy})
    ,M:=new_map() % hashmap to store the definitions of the symbols
    ,foreach(L in A,L.length=2) % the constants
        M.put(L[1],[L[2].to_int]) % are stored as such
    end
    ,foreach(L in A,L.length=5) % the gates
        V:=new_array(1),V::0..1,V:=V[1], %real output of the gate
        Vafter:=new_array(1),Vafter::0..1,Vafter:=Vafter[1], %output used after a potential swap
        Vswap:=VarSwaps.get(L[5]), % the same swap being employed for every addition X+Y
        M.put(L[5],[V,Vafter,Vswap,L[2],L[1],L[3],L[5]]), %store all info needed later
    end    
    ,foreach(L in A,L.length=5)
        add_gate_constr(M,Swappers,Vx,Vy,M.get(L[5])) %add a gate and potential swap constraint for every gate
    end    
    ,Vz:=[R:X in Zs,e(Vx,Vy,M,Swappers,X,R)] % collect the outputs of the "Z" gates on X and Y
    ,madd(0,Vx,Vy,Vz) % enforce Vx+Vy=Vz with suitable swapps
end
,p(solve)
,solve(Vars++Vaft++Vpos) %solve the constraint problem
,Swappednames=[N:[_,_,V,_,_,_,N] in M.values,V.sum>0].sort %extract the names of the gates swapped
,p(Swappednames) %and display them after sort
.
