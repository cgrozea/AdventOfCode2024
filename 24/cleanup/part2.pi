import util.
import sat.
p(A)=>println(A). %shorter alias
op("OR",X,Y,R)=>R#=(X#\/Y).  %add OR constraint
op("AND",X,Y,R)=>R#=(X#/\Y). %add AND constraint
op("XOR",X,Y,R)=>R#=(X#^Y).  %add XOR constraint

%evaluate X to a value R using potential swapps
e(Vx,Vy,M,Swappers,X,R)=> 
L=M.get(X,[notfound]),
if L=[R2] then
    if X[1]='x' then
        R=Vx[tail(X).to_int+1] % "X" input
    else
            if X[1]='y' then
                R=Vy[tail(X).to_int+1] % "Y" input
            else
                R=R2,exit(0) % there shouldn't be other type of input
            end                
    end
else
   L=[_,Vafter|_],R=Vafter %whoever references a gate uses the value after a potential swap
end.

% constraint for gate behavior and potential swap after
add_gate_constr(M,Swappers,Vx,Vy,L)=>
L=[V,Vafter,Vswap,Op,T1,T2,Name], %expand the info about the gate instance
e(Vx,Vy,M,Swappers,T1,V1), %evaluate operand T1 to V1
e(Vx,Vy,M,Swappers,T2,V2), %evaluate operand T2 to V2
op(Op,V1,V2,V), %enforces the gate relation V=Op(V1,V2), where V is the value before swap
(sum(Vswap)#=0)#/\(Vafter#=V) % when not involved in swapps, the value remains unchanged
#\/ (sum(Vswap)#>0) #/\ 
(
Vswap[1] #/\ V#=Swappers[1] %a) when it participates in slot 1 ...
#\/ Vswap[2] #/\ V#=Swappers[2] %b) when it participates in slot 2 ...
#\/ Vswap[3] #/\ V#=Swappers[3] % and so on
#\/ Vswap[4] #/\ V#=Swappers[4]
#\/ Vswap[5] #/\ V#=Swappers[5]
#\/ Vswap[6] #/\ V#=Swappers[6]
#\/ Vswap[7] #/\ V#=Swappers[7]
#\/ Vswap[8] #/\ V#=Swappers[8]
)
#/\
(
Vswap[1]#/\ Vafter#=Swappers[2] %a) then it swaps with whatever value the gate participating in slot 2 produces
#\/ Vswap[2] #/\ Vafter#=Swappers[1] %a) then it swaps with whatever value the gate participating in slot 1 produces
#\/ Vswap[3] #/\ Vafter#=Swappers[4] % and so on
#\/ Vswap[4] #/\ Vafter#=Swappers[3]
#\/ Vswap[5] #/\ Vafter#=Swappers[6]
#\/ Vswap[6] #/\ Vafter#=Swappers[5]
#\/ Vswap[7] #/\ Vafter#=Swappers[8]
#\/ Vswap[8] #/\ Vafter#=Swappers[7]
)
.

% enforces the multibit binary addition constraint
% on arbitrary length numbers X and Y
% with the result on Z (one bit longer than X and Y)
% C is the carry
% X+Y+C=Z
madd(C,X,Y,Z)=>
foreach(I in 1..X.length)
    Z[I] #= (X[I] #^ Y[I] #^ C),
    D:=new_array(1),D::0..1,D:=D[1],
    D#=((X[I] + Y[I] + C) #>= 2),
    C:=D
end,
Z[Z.length]#=C.

% main entry point
% command line parameters:
% - file name F
% - number of gates involved in swapps (8 in the AoC problem)
% - for how many random additions to constrain the circuit to function correctly: Steps
main([F,K0,Steps])=>
A=[X.split(": "): X in read_file_lines(F)] %parse the symbols definitions in the input file
,M=new_map() %stores the informations from the input file as a map with symbol names as keys
,W=new_set() %stores all symbol names
,foreach(L in A,L.length=2) %process the definitions of the constants (circuit inputs)
    M.put(L[1],[L[2].to_int]),
    W.put(L[1])
end
,VarSwaps=new_map(45) %stores the associated variable to a gate, the value after the potential swap
,foreach(L in A,L.length=5) %processes the definitions of the gates
    if M.has_key(L[5]) then %if already seen (shouldn't be the case)
        p("duplicate"),
        exit(0)
    end,
    Vswap=new_array(8),Vswap::0..1, %if this variable is swapped with any of the slots
    VarSwaps.put(L[5],Vswap), %associate these flags with the variable
    M.put(L[5],[V,[],[],L[2],L[1],L[3],L[5]]), %store the original gate info and the variables
    W.put(L[5]), %and make sure 
    W.put(L[1]), %the symbols involved 
    W.put(L[3])  %are collected
end
,K=K0.to_int
,SK=M.keys.sort
,SKN=SK.length
,Vpos=[V:I in 1..SKN,M.get(SK[I])=[_,_,V|_]] %all swapp flags
,SG=[V:I in 1..SKN,M.get(SK[I])=[_,_,_,_,_,_,V]] %all symbols for gates
,SGN=SG.length
,foreach(X in Vpos)
    sum(X)#<=1 %every gate takes part in atmost one swap slot
end
,foreach(I in 1..K)
    sum([X[I]:X in Vpos])#=1 %every slot is used to swap the output of precisely one gate
end
,sum([sum(X):X in Vpos])#=K %there are exactly K swapped gate outputs
,Xs=[X:X in W.keys,X[1]='x'].sort % "X" symbols in order, LSB first
,Ys=[X:X in W.keys,X[1]='y'].sort % "Y" symbols in order, LSB first
,Zs=[X:X in W.keys,X[1]='z'].sort % "Z" symbols in order, LSB first
,p(lengths=[Xs,Ys,Zs].map(length))
,Ax:=random(42) % geeky random seed
,foreach(Rep in 1..Steps.to_int) %generate Steps random additions
    p(Rep)    
    ,Swappers=new_array(8),Swappers::0..1 %the values swapped
    ,Vx:=[random(0,1):_ in Xs] %random X
    ,Vy:=[random(0,1):_ in Ys] %to add with random Y   
    ,p({Vx,Vy})
    ,M:=new_map() % hashmap to store the definitions of the symbols
    ,foreach(L in A,L.length=2) % the constants
        M.put(L[1],[L[2].to_int]) % are stored as such
    end
    ,foreach(L in A,L.length=5) % the gates
        V:=new_array(1),V::0..1,V:=V[1], %real output of the gate
        Vafter:=new_array(1),Vafter::0..1,Vafter:=Vafter[1], %output used after a potential swap
        Vswap:=VarSwaps.get(L[5]), % the same swap being employed for every addition X+Y
        M.put(L[5],[V,Vafter,Vswap,L[2],L[1],L[3],L[5]]), %store all info needed later
    end    
    ,foreach(L in A,L.length=5)
        add_gate_constr(M,Swappers,Vx,Vy,M.get(L[5])) %add a gate and potential swap constraint for every gate
    end    
    ,Vz:=[R:X in Zs,e(Vx,Vy,M,Swappers,X,R)] % collect the outputs of the "Z" gates on X and Y
    ,madd(0,Vx,Vy,Vz) % enforce Vx+Vy=Vz with suitable swapps
end
,p(solve)
,solve(Vpos) %solve the constraint problem
,Swappednames=[N:[_,_,V,_,_,_,N] in M.values,V.sum>0].sort %extract the names of the gates swapped
,p(Swappednames) %and display them after sort
.
